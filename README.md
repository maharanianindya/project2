PWS Application : https://maharani-anindya-project2.pbp.cs.ui.ac.id/

## Assignment 2
1. Explain how you implemented the checklist above step-by-step

I started by creating a new Django project and an app main. after that, I register the main application on the project, by adding 'main' inside settings.py. Then, I add a urls.py file inside the main app, and link it in project2/urls.py with path('', include('main.urls')) so requests to the root URL are directed to the main application. Next, I create a model in models.py called Product with all required attributes: name, price, description, thumbnail, category, is_featured. then, I ran makemigrations to create model migrations, ran migrate to apply migrations to the local database. After that, I registered the model in admin.py. In views.py, I create a function called show_main to fetch all products from the database and include data such as the app name, my name, my class. Then, I make a templates to loop through the product list and display each item. If none exist, loop through {% empty %} . after that, I create routing in urls.py of the main app to map the function in views.py 
finally, I deployed the application to PWS with git push pws master. 

2. Create a diagram showing the client request to the Django-based web application and its response, and explain the relationship between urls.py, views.py, models.py, and the HTML file in the diagram.

<img width="1034" height="254" alt="image" src="https://github.com/user-attachments/assets/0cae6ab9-59ba-488b-bcb9-6141525c023b" />

urls.py directs a user's request to the right function in views.py, which may use models.py to get or save the data. The views then sends that data to an HTML template, which displays the final page the user sees in the browser. 

3. Explain the role of settings.py in a Django project!

The settings.py file configures the Django project by defining apps, middleware, templates, database connections, static files, and security options. It serves as the project's main configuration, making sure the application works properly in both development and production settings. 

4. How does database migration work in Django?

In Django, migrations handle database schema updates. running makemigrations generates instructions based on model changes, and migrate applies them so the database stays consistent with the models. 

5. In your opinion, among all existing frameworks, why is the Django framework chosen as the starting point for learning software development?

Because it is beginner friendly, and it provides an all-in-one framework with built-in features such as ORM, authentication, and an admin interface, which makes it simpler for beginners to get started.

6. Do you have any feedback for the teaching assistant for Tutorial 1 that you previously completed?
The instructions were quite clear and easy to follow, which made it helpful for understanding the basics of Django.

## Assignment 3 
1. Why do we need data delivery in implementing a platform?
because data delivery ensures prompt, reliable, and secure information flow across services, it enables low latency, and personalized experiences. Without it, platforms become inconsistent and delay prone , reduce user experience, and face increased compliance risk.

2. In your opinion, which is better, XML or JSON? 
In my opinion, JSON is better than XML because it is lighter, easier to read, and integrate seamlessly with native data types. This results in smaller payloads and lighter parsing, which lowers latency, enhances user experience, and faster development.
Why is JSON more popular than XML? because it is a natural fit for Javascript and easy in most language, less verbose, and generally faster to parse for common API shapes 

3. What is the purpose of the is_valid() method in Django forms
is_valid() method verifies submitted data and ensures the data is consistent valid before saving it to the database
and why do we need it? because it checks form input against field constraints, cleanse it to reduce security risks, and convert raw strings into correctly typed values.

4. Why do we need a csrf_token when making forms in Django? 
because it is a security token and is automatically generated by django to prevent attacks
What can happen if we don't include a csrf_token in a Django form? the server might execute unauthorized, state-changing requests leveraging the user's authenticated cookies: changing email/password, modifying or deleting data that can lead to data loss.
How can this be exploited by an attacker? an attacker may lead an authenticated user into a malicious page that sends a request to the user site, using the userâ€™s session cookies that the browser automatically includes

5. Explain how you implemented the checklist above step-by-step (not just following the tutorial).
first, I implement 4 functions that return the object as XML and JSON, both for the full collection and for a single item by ID in views.py. then, add matching URL routes whose path parameter names and types align with the view arguments. after that, I make a templates/folder, create a base.html, the base.html file is a base template that used as generic view for other web pages within the project. and, I add 'DIRS': [BASE_DIR / 'templates'] in settings.py. after that, I create forms.py file to define the form structure that will collect data. then, in views.py I create 2 functions called add_product and product_detail, I import all the functions in urls.py and add the URL path to the urlpatterns variable. I update the main.html templates with an "add" and "detail" button that redirects to the form page. after that, I create 2 html files (add_product.html & product_detail.html) to create an input form and product detail page. I add a new variable (CSRF) in settings.py to prevent attacks. finally, run the server and push to github and pws.

6. Do you have any feedback for the teaching assistants for Tutorial 2?
The teaching assistants were super helpful whenever I had issues, they responded quickly, and helped me through the debugging steps. 
POSTMAN : 
<img width="2940" height="1912" alt="image" src="https://github.com/user-attachments/assets/0ddaf031-a837-4587-a30e-e3956a6ef804" />
<img width="2940" height="1912" alt="image" src="https://github.com/user-attachments/assets/7eebf29c-f1a7-4cba-a637-eee79009fdd3" />
<img width="2940" height="1912" alt="image" src="https://github.com/user-attachments/assets/7713eabd-652f-407d-a4a0-aef02833c929" />
<img width="2940" height="1912" alt="image" src="https://github.com/user-attachments/assets/7c479edd-2c18-4589-8c63-ed6a0fced3d4" />

## Assignment 4 
1. Django's AuthenticationForm is a built-in form class that manages user authentication by verifying a username and password using the Django's authentication system. It provides a secure, structured approach to login handling, protecting against XSS and CSRF, and accelerates development by providing a pre-built solution. another benefit is that the form validates the username and password, confirming that inputs meet the necessary requirements. However, Django's Authentication also have some disadvantages, because Django's authentication system is designed to be generic, AuthenticationForm does not provide some advanced features found in other systems. for advance needs such as limiting login attempts or enforcing password strength rules, third party packages or custom implementations are required.
   
2. The difference is authentication is the process of verifying who you are:login, meanwhile authorization is the process of verifying that you have access to something. Django implements the authentication concept by verifying user identity with the User model, pluggable authentication backends, and the authenticate() function, while AuthenticationMiddleware attaches the authenticated user (or an AnonymousUser) to each request. Authorization relies on permissions and groups to control access, allowing developers to restrict access at the view or object level using decorators and explicit permission checks.

3. Sessions store state on the server, which improves security (only a session ID is sent to the client), supports more data than cookies, and gives the server full control over creation, updates, and deletion, making sessions suitable for sensitive data like logins or carts. However, they consume server capacity, require expiration and garbage collection, add complexity to HTTP's stateless nature, and can be hijacked if the session ID leaks. Cookies keep small data on the client and can persist beyond a single session, enabling "remember me" preference storage, and lightweight tracking while easing server state management and allowing client side access. However, they are limited in size, added overhead since they're sent with every request, can be disabled or deleted by users, and raise privacy concerns.

4. No, cookies are not secure by default, as client side storage and automatic transmission introduces risks such as XSS, CSRF, session fixation, and interception over plain HTTP. Django addresses these by using server side sessions with a random session ID (sessionid), built in CSRF protection, and middleware that promotes safe defaults. 

5. First, I activated the virtual environment in the terminal, then added a register() in views.py using UserCreationForm, created register.html, and linked it in urls.py so new users can sign up. Next, I added the login_user() in views.py , created login.html, and linked it in urls.py to require a login to access the main page. Then I implemented logout with logout_user(request), added the route in urls.py, and placed a Logout button on main.html. After that, I imported login_required and applied @login_required(login_url='/login') to show_main() and product_detail() so only authenticated users can access those pages. I created two local user accounts and added three products per account. I then added user = models.ForeignKey(User, on_delete=models.CASCADE, null=True) to the model and ran migrations to link each product to its author. In add_product, I used commit=False, set product_entry.user = request.user, and saved the object so every product belongs to the logged-in user. I also updated show_main, added filter buttons in main.html, and displayed the authorâ€™s username in product_detail.html. Next, in login_user I set a last_login cookie with the current timestamp, displayed it in show_main via request.COOKIES.get('last_login', 'Never'), and rendered it in main.html. In logout_user, I removed the last_login cookie before redirecting; after logging in, I refreshed to see the value on the main page and confirmed last_login, sessionid, and csrftoken.

   

